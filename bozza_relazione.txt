In this short report i will explain the reason that brought me to this specific implementation, the problems encountered and a small guide on how to use the program.

Operation 
The main goal was shuffling an input text using go routines and message passing communication only. 
The first thing the program does is calculating how many words each worker will have. This number is represented by the segment. So each worker will have a similar amount of word to work on. For example, if the text is 22 words long, and the program will use 3 workers, two routines will work on 7 words and one will work on 8.

The assignment of the words is the first layer of randomization. One unbuffered shared channel is created to distribute the words, each routine will receive one word per time from the channel. Since the operation is blocking, concurrency will make the distribution of words not deterministic. 
The first problem encountered was here. In the first try i tried to use a buffered channel, but given how the Go scheduler works, words were assigned basically in order, so i preferred using an unbuffered channel. Even though this is not enough since segments will have a lot of continguous words (this is still caused by the go scheduler, that tries to reduce unnecessary swapping between routines as much as possible).

After the words are assigned, each worker will perform a local shuffle. 
After the local shuffle, only the aggregation remains. 
One channel per worker is created and all of them are grouped in a slice, this channel will be used to do the aggregation.
Each routine will write every word in a random choose channel. After all words are written in the channels, the routines will stop and the results are aggregated in a single resulting list. 

As already said, the scheduler tends to reduce swapping between routines as much as possible, so the first results obtained with only this approach were not satisfying enough since a lot of contiguous words appeared in blocks of the size of the segments assigned to each worker. 
To make the process completely random and unpredictable, another run of the same identical algorithm is applied, starting from the already shuffled list and with another random number of workers.

In short, the main issue was the fact that words were kept in blocks of the size of routines, so basically there were shuffles local to this blocks. The interleaving of the routines was not enough to grant a completely unpredictable shuffle of the words, so i preferred to increase calculations to grant more randomization. To overcome the issue, the previous solution was the one that i thought fitted the best in this case, even though I'm sure some better solution exists. 

Another approach i tried was by using the switch statement, but even that grouped words by bursts and made it pretty predicibile and not enough random for what i was looking for. 


///
Introduction

In this brief report, I will explain the rationale behind my specific implementation, discuss the challenges encountered, and provide a short guide on how to use the program.
Operation

The primary objective was to shuffle an input text using Go routines and message-passing communication exclusively. The program begins by calculating the number of words each worker will handle, referred to as a segment. This ensures that each worker processes a roughly equal portion of the text. For example, if the text contains 22 words and the program utilizes 3 workers, two routines will handle 7 words each, while one will process 8.

The assignment of words is the first layer of randomization. To distribute the words, the program creates a shared unbuffered channel. Each routine receives one word at a time from this channel. Since the operation is blocking, the distribution of words becomes non-deterministic due to concurrency. Initially, I attempted to use a buffered channel, but this led to words being assigned almost sequentially due to the behavior of the Go scheduler. Therefore, I opted for an unbuffered channel. However, even this approach was insufficient, as segments still contained many contiguous words. This is because the Go scheduler minimizes unnecessary swapping between routines.

Once the words are assigned, each worker performs a local shuffle. After this local shuffle, the only task remaining is aggregation. To achieve this, a channel is created for each worker, and these channels are grouped in a slice. These channels are then used for the aggregation process. Each routine writes every word to a randomly chosen channel. Once all words are written, the routines terminate, and the results are aggregated into a single list.

As mentioned earlier, the scheduler's tendency to minimize swapping between routines meant that the initial results were unsatisfactory, with many contiguous words appearing in blocks corresponding to the segments assigned to each worker. To achieve a more random and unpredictable shuffle, I applied the same algorithm a second time, using the already shuffled list and a different random number of workers.
Conclusion

In summary, the primary challenge was that words tended to remain in blocks corresponding to the size of the worker segments, resulting in only local shuffling within these blocks. The interleaving of routines was insufficient to produce a completely unpredictable shuffle. To address this issue, I increased the computational complexity to enhance randomization. While the solution I implemented appears to be the most suitable for this case, I acknowledge that there may be more efficient approaches available.
